
with(numtheory); with(LinearAlgebra); with(Groebner);
BM := proc (s, N, P, x) local C, B, T, L, k, i, n, d, b, safemod; ASSERT(nops(s) = 2*N); safemod := proc (exp, P) options operator, arrow; `if`(P = 0, exp, `mod`(exp, P)) end proc; B := 1; C := 1; L := 0; k := 1; b := 1; for n from 0 to 2*N-1 do d := s[n+1]; for i to L do d := safemod(d+coeff(C, x^i)*s[n-i+1], P) end do; if d = 0 then k := k+1 end if; if d <> 0 and n < 2*L then C := safemod(expand(C-d*x^k*B/b), P); k := k+1 end if; if d <> 0 and 2*L <= n then T := C; C := safemod(expand(C-d*x^k*B/b), P); B := T; L := n+1-L; k := 1; b := d end if end do; return C end proc;



Vinvert := proc (c, v::list, a::list, p)::list; local i, n, c1, d, q, q1, q2; n := nops(c)-1; d := 0; q1 := 0; c1 := []; for i to n do d := d+a[i]*z^(n+1-i) end do; q := `mod`(expand(c*d), p); for i to n do q1 := q1+coeff(q, z, 2*n+1-i)*z^(n-i) end do; q2 := diff(c, z); for i to n do c1 := [op(c1), `mod`((eval(q1, z = v[i]))/(eval(q2, z = v[i])), p)] end do; return c1 end proc;

MC := proc (a::list, p)::anything; local a1, v, u, n, q, f, m, i, c, q1; n := (1/2)*nops(a); u := []; v := []; q := []; f := BM(a, n, p, x); m := degree(f); a1 := z^m; for i to m do a1 := a1+coeff(f, x, i)*z^(m-i) end do; q1 := `mod`(Roots(a1), p); for i to m do q := [op(q), a[i]] end do; for i to m do v := [op(v), q1[i, 1]] end do; if 1 < m then c := Vinvert(a1, v, q, p) else c := [a[1]] end if; for i to m do u := [op(u), [c[i], v[i]]] end do; return sort(u) end proc;

MBOT := proc (M, n, T, omega, zeta, p)::anything; local N, a, j, t, c, i, E, r, f, u, c1; a := []; for j to 2*T do a := [op(a), M[1, j]] end do; a := MC(a, p); t := nops(a); c := []; for i to t do c := [op(c), a[i, 1]] end do; N := Matrix(n+1, t); for j to t do N[1, j] := N[1, j]+a[j, 2] end do; for i from 2 to n+1 do a := []; for j to 2*T do a := [op(a), M[i, j]] end do; a := MC(a, p); if nops(a) <> t then return failure end if; for j to t do N[i, j] := a[j, 2] end do end do; E := Matrix(n, t); for i to n do for j to t do r := N[i+1, j]/N[1, j]; E[i, j] := mlog(r, omega, p) end do end do; f := 0; for i to t do u := 1; c1 := c[i]; for j to n do u := u*x[j]^E[j, i]; c1 := `mod`(c1/zeta[j]^E[j, i], p) end do; f := f+c1*u end do; return f end proc;

mydiver := proc (f, n, zeta, p) local i, g; g := f; for i to n do g := `mod`(eval(g, x[i] = zeta[i]*x[i]), p) end do; return g end proc;

my_testing_term := proc (A::Matrix, p::integer) if `mod`(Det(A), p) = 0 then return 1 else return 0 end if end proc;


# Algorithm used to compute the i-th power of alpha

mypower := proc (k, n, alpha, p) local i, beta; beta := []; for i to n do beta := [op(beta), `mod`(alpha[i]^k, p)] end do; return beta end proc;

myeval := proc (n, alpha) local i, X; X := []; for i to n do X := [op(X), x[i] = alpha[i]] end do; return X end proc;

myomegaalpha := proc (k, n, alpha, omega, p) local i, beta; beta := []; for i to n do if i = k then beta := [op(beta), `mod`(alpha[i]*omega, p)] else beta := [op(beta), alpha[i]] end if end do; return beta end proc;




findMaxSubs := proc (A, s) local i, dmax, flag, d1, A1, k, Q, myTerm, dmin, S, T, n; dmax := -1; dmin := infinity; n := nops(s); myTerm := [op(A)]; flag := 0; S := []; T := nops(myTerm); for i to T do d1 := 0; for k to n do d1 := d1+degree(myTerm[i], x[k])*s[k] end do; S := [op(S), [myTerm[i], d1]]; if dmax < d1 then dmax := d1; flag := 1; Q := myTerm[i] elif d1 = dmax then flag := flag+1 end if; if d1 < dmin then dmin := d1 end if end do; A1 := 0; for i to T do A1 := A1+S[i][1]*y^(S[i][2]-dmin) end do; if flag = 1 then return [A1, Q] else return Failure end if end proc;
findSubs := proc (A, s) local i, d1, A1, k, myTerm, dmin, S, T, n; dmin := infinity; n := nops(s); myTerm := [op(A)]; S := []; T := nops(myTerm); for i to T do d1 := 0; for k to n do d1 := d1+degree(myTerm[i], x[k])*s[k] end do; S := [op(S), [myTerm[i], d1]]; if d1 < dmin then dmin := d1 end if end do; A1 := 0; for i to T do A1 := A1+S[i][1]*y^(S[i][2]-dmin) end do; return A1 end proc;
myFindsubs := proc (A, B, n, p) local flag, T, s, i, H1, H2, Q, flag1; flag := 0; flag1 := 1; for T while flag = 0 do s := []; for i to n do s := [op(s), RandomTools[Generate](integer(range = 0 .. T))] end do; H1 := findMaxSubs(A, s); H2 := findMaxSubs(B, s); while H1 = Failure and H2 = Failure and flag1 <= 3 do H1 := findMaxSubs(A, s); H2 := findMaxSubs(B, s); flag1 := flag1+1 end do; flag1 := 1; if H1 <> Failure or H2 <> Failure then flag := 1 else T := 2*T end if end do; if H1 = Failure then H1 := findSubs(A, s) else Q := H1[2]; H1 := H1[1] end if; if H2 = Failure then H2 := findSubs(B, s) else Q := H2[2]; H2 := H2[1] end if; return [H1, H2, Q] end proc;
myMinDegree := proc (A, n) local dmin, i, j, d, S; dmin := []; for i to n do dmin := [op(dmin), infinity] end do; S := [op(A)]; for i to nops(S) do for j to n do d := degree(S[i], x[j]); if d < dmin[j] then dmin[j] := d end if end do end do; return dmin end proc;



mynewgcd := proc (Ori_A, Ori_B, p) local i, V, n, X, A, B, H, zeta, alpha, F1, F2, H_1, F11, F22, q, De, m, Tb, Point, T, N, k, My_Hankel, Discr, M, j, U, Y, s1, s2, s, P; V := {op(indets(Ori_A)), op(indets(Ori_B))}; n := nops(V); if n = 1 then return `mod`(Gcd(Ori_A, Ori_B), p) end if; X := []; for i to n do X := [op(X), V[i] = x[i]] end do; A := eval(Ori_A, X); B := eval(Ori_B, X); s1 := myMinDegree(A, n); s2 := myMinDegree(B, n); s := []; for i to n do s := [op(s), min(s1[i], s2[i])] end do; H := myFindsubs(A, B, n, p); F1 := H[1]; F2 := H[2]; H := H[3]; zeta := []; for i to n do zeta := [op(zeta), RandomTools[Generate](integer(range = 1 .. p-1))] end do; alpha := []; for i to n do alpha := [op(alpha), RandomTools[Generate](integer(range = 1 .. p-1))] end do; F1 := mydiver(F1, n, zeta, p); F2 := mydiver(F2, n, zeta, p); H_1 := mydiver(H, n, zeta, p); F11 := `mod`(Eval(F1, myeval(n, mypower(1, n, alpha, p))), p); F22 := `mod`(Eval(F2, myeval(n, mypower(1, n, alpha, p))), p); q := `mod`(Gcd(F11, F22), p); coeffs(q, y, 'De'); De := [De]; De := subsop(1 = NULL, De); m := nops(De); if m = 0 then Y := []; for i to n do Y := [op(Y), x[i] = V[i]] end do; return eval(H, Y) end if; for i to m do Tb[i] := 1 end do; for i to m do Point[i] := 0 end do; T := 1; for i to m do N[i] := [] end do; F11 := `mod`(Eval(F1, myeval(n, mypower(0, n, alpha, p))), p); F22 := `mod`(Eval(F2, myeval(n, mypower(0, n, alpha, p))), p); q := `mod`(Gcd(F11, F22), p); q := `mod`(`mod`(q*(Eval(H_1, myeval(n, mypower(0, n, alpha, p))))/lcoeff(q), p), p); for k to m do N[k] := [op(N[k]), coeff(q, y, degree(De[k]))] end do; Discr := 0; while Discr < m do for i from 2*T-1 to 2*T do F11 := `mod`(Eval(F1, myeval(n, mypower(i, n, alpha, p))), p); F22 := `mod`(Eval(F2, myeval(n, mypower(i, n, alpha, p))), p); q := `mod`(Gcd(F11, F22), p); q := `mod`(`mod`(q*(Eval(H_1, myeval(n, mypower(i, n, alpha, p))))/lcoeff(q), p), p); for k to m do if Point[k] = 0 then N[k] := [op(N[k]), coeff(q, y, degree(De[k]))] end if end do end do; for i to m do if Point[i] = 0 then My_Hankel := HankelMatrix(N[i]); if my_testing_term(My_Hankel, p) = 1 then Tb[i] := T; Point[i] := 1 end if end if end do; T := T+1; Discr := 0; for i to m do Discr := Discr+Point[i] end do end do; T := T-1; for i to m do M[i] := Matrix(n+1, 2*Tb[i]) end do; for k to m do for i to 2*Tb[k] do M[k][1, i] := N[k][i] end do end do; for j to n do for i from 0 to 2*T-1 do F11 := `mod`(Eval(F1, myeval(n, mypower(i, n, myomegaalpha(j, n, alpha, omega, p), p))), p); F22 := `mod`(Eval(F2, myeval(n, mypower(i, n, myomegaalpha(j, n, alpha, omega, p), p))), p); q := `mod`(Gcd(F11, F22), p); q := `mod`(`mod`(q*(Eval(H_1, myeval(n, mypower(i, n, myomegaalpha(j, n, alpha, omega, p), p))))/lcoeff(q), p), p); for k to m do if i+1 <= 2*Tb[k] then M[k][j+1, i+1] := coeff(q, y, degree(De[k])) end if end do end do end do; U := H; for i to m do U := U+MBOT(M[i], n, Tb[i], omega, zeta, p) end do; Y := []; for i to n do Y := [op(Y), x[i] = V[i]] end do; P := eval(U, Y); s1 := myMinDegree(P, n); U := 1; for i to n do U := U*x[i]^(s1[i]-s[i]) end do; return `mod`(Expand(P/U), p) end proc;
